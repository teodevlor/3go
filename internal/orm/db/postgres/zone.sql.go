// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: zone.sql

package pgdb

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countZones = `-- name: CountZones :one
SELECT COUNT(*) FROM system_zones
WHERE deleted_at IS NULL
  AND ($1 = '' OR name ILIKE '%' || $1 || '%' OR code ILIKE '%' || $1 || '%')
`

func (q *Queries) CountZones(ctx context.Context, dollar_1 interface{}) (int64, error) {
	row := q.db.QueryRow(ctx, countZones, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createZone = `-- name: CreateZone :one
INSERT INTO system_zones (
  code,
  name,
  polygon,
  price_multiplier,
  is_active
)
VALUES (
  $1,
  $2,
  ST_SetSRID(
    ST_GeomFromGeoJSON($3),
    4326
  ),
  $4,
  $5
)
RETURNING id, code, name, polygon, price_multiplier, is_active, created_at, updated_at, deleted_at
`

type CreateZoneParams struct {
	Code              string         `json:"code"`
	Name              string         `json:"name"`
	StGeomfromgeojson interface{}    `json:"st_geomfromgeojson"`
	PriceMultiplier   pgtype.Numeric `json:"price_multiplier"`
	IsActive          bool           `json:"is_active"`
}

func (q *Queries) CreateZone(ctx context.Context, arg CreateZoneParams) (SystemZone, error) {
	row := q.db.QueryRow(ctx, createZone,
		arg.Code,
		arg.Name,
		arg.StGeomfromgeojson,
		arg.PriceMultiplier,
		arg.IsActive,
	)
	var i SystemZone
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Polygon,
		&i.PriceMultiplier,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteZone = `-- name: DeleteZone :exec
UPDATE system_zones
SET deleted_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteZone(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteZone, id)
	return err
}

const getZoneByCode = `-- name: GetZoneByCode :one
SELECT id, code, name, ST_AsGeoJSON(polygon)::text AS polygon_geojson, price_multiplier, is_active, created_at, updated_at, deleted_at
FROM system_zones
WHERE code = $1 AND deleted_at IS NULL
`

type GetZoneByCodeRow struct {
	ID              uuid.UUID          `json:"id"`
	Code            string             `json:"code"`
	Name            string             `json:"name"`
	PolygonGeojson  string             `json:"polygon_geojson"`
	PriceMultiplier pgtype.Numeric     `json:"price_multiplier"`
	IsActive        bool               `json:"is_active"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) GetZoneByCode(ctx context.Context, code string) (GetZoneByCodeRow, error) {
	row := q.db.QueryRow(ctx, getZoneByCode, code)
	var i GetZoneByCodeRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.PolygonGeojson,
		&i.PriceMultiplier,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getZoneByID = `-- name: GetZoneByID :one
SELECT id, code, name, ST_AsGeoJSON(polygon)::text AS polygon_geojson, price_multiplier, is_active, created_at, updated_at, deleted_at
FROM system_zones
WHERE id = $1 AND deleted_at IS NULL
`

type GetZoneByIDRow struct {
	ID              uuid.UUID          `json:"id"`
	Code            string             `json:"code"`
	Name            string             `json:"name"`
	PolygonGeojson  string             `json:"polygon_geojson"`
	PriceMultiplier pgtype.Numeric     `json:"price_multiplier"`
	IsActive        bool               `json:"is_active"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) GetZoneByID(ctx context.Context, id uuid.UUID) (GetZoneByIDRow, error) {
	row := q.db.QueryRow(ctx, getZoneByID, id)
	var i GetZoneByIDRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.PolygonGeojson,
		&i.PriceMultiplier,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listZones = `-- name: ListZones :many
SELECT id, code, name, ST_AsGeoJSON(polygon)::text AS polygon_geojson, price_multiplier, is_active, created_at, updated_at, deleted_at
FROM system_zones
WHERE deleted_at IS NULL
  AND ($1 = '' OR name ILIKE '%' || $1 || '%' OR code ILIKE '%' || $1 || '%')
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListZonesParams struct {
	Column1 interface{} `json:"column_1"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type ListZonesRow struct {
	ID              uuid.UUID          `json:"id"`
	Code            string             `json:"code"`
	Name            string             `json:"name"`
	PolygonGeojson  string             `json:"polygon_geojson"`
	PriceMultiplier pgtype.Numeric     `json:"price_multiplier"`
	IsActive        bool               `json:"is_active"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) ListZones(ctx context.Context, arg ListZonesParams) ([]ListZonesRow, error) {
	rows, err := q.db.Query(ctx, listZones, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListZonesRow{}
	for rows.Next() {
		var i ListZonesRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.PolygonGeojson,
			&i.PriceMultiplier,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateZone = `-- name: UpdateZone :one
UPDATE system_zones
SET
  code = $2,
  name = $3,
  polygon = ST_SetSRID(ST_GeomFromGeoJSON($4), 4326),
  price_multiplier = $5,
  is_active = $6,
  updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, code, name, polygon, price_multiplier, is_active, created_at, updated_at, deleted_at
`

type UpdateZoneParams struct {
	ID                uuid.UUID      `json:"id"`
	Code              string         `json:"code"`
	Name              string         `json:"name"`
	StGeomfromgeojson interface{}    `json:"st_geomfromgeojson"`
	PriceMultiplier   pgtype.Numeric `json:"price_multiplier"`
	IsActive          bool           `json:"is_active"`
}

func (q *Queries) UpdateZone(ctx context.Context, arg UpdateZoneParams) (SystemZone, error) {
	row := q.db.QueryRow(ctx, updateZone,
		arg.ID,
		arg.Code,
		arg.Name,
		arg.StGeomfromgeojson,
		arg.PriceMultiplier,
		arg.IsActive,
	)
	var i SystemZone
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Polygon,
		&i.PriceMultiplier,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
